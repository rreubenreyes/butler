package nodejs

import (
	"log"
	"os"
)

type Builder struct {
	target             *Target
	buildDir           string
	usedImports        []string
	dependencyFilePath string
	lockFilePath       string
}

func removeUnusedImportsFromLockFile(imports []string, path string) error {
	// traverse and remove imports from package-lock.json
}

func removeUnusedImportsFromDependencyFile(imports []string, path string) error {
	// traverse and remove imports from package.json
}

func (b *Builder) discoverUsedImports() error {
	// traverse each import found in the entrypoint file, scanning for
	// absolute dependencies managed by node_modules
}

func (b *Builder) removeUnusedImports() error {
	if !b.target.DryRun {
		log.Printf("target is configured for dry run; won't remove unused imports")
		return nil
	}
	if b.target.IgnoreLockFile {
		return removeUnusedImportsFromDependencyFile(b.usedImports, b.dependencyFilePath)
	}

	return removeUnusedImportsFromLockFile(b.usedImports, b.lockFilePath)
}

// copyBuildFiles copies all files in the Target's project root to this Builder's build directory.
func (b *Builder) copyBuildFiles() error {
	if !b.target.DryRun {
		log.Printf("target is configured for dry run; won't copy build files")
		return nil
	}
}

// createBuildArtifact creates a build artifact using files in the temporary build directory.
func (b *Builder) createBuildArtifact() error {
	if !b.target.DryRun {
		log.Printf("target is configured for dry run; won't create a build artifact")
		return nil
	}
}

// cleanup removes the temporary build directory and any unused side effects generated by this
// build process.
func (b *Builder) cleanup() {
	if !b.target.DryRun {
		log.Printf("target is configured for dry run; nothing to cleanup")
	}
}

// buildDir creates a temporary build directory and sets this Builder's buildDir
// property to that directory.
func (b *Builder) createBuildDir() error {
  // if dry run, carry out dry run build using actual project root since no side effects
  // will be performed
	if !b.target.DryRun {
		log.Printf("target is configured for dry run; won't create a new build directory")
    b.buildDir = b.target.ProjectRoot

		return nil
	}

	dir, err := os.MkdirTemp("", "butler_build")
	if err != nil {
		return err
	}

	b.buildDir = dir

	return nil
}

func (b *Builder) Build() error {
	defer b.cleanup()

	err := b.createBuildDir()
	err = b.copyBuildFiles()
	if b.target.RemoveUnusedImports {
		err = b.discoverUsedImports()
		err = b.removeUnusedImports()
	}
	err = b.createBuildArtifact()
}
