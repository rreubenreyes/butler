package nodejs

import (
	"context"
	"os"

	"github.com/rreubenreyes/butler/internal/log"
)

type Builder struct {
	ctx                context.Context
	target             *Target
	buildDir           string
	usedImports        []string
	dependencyFilePath string
	lockFilePath       string
}

func (b *Builder) removeUnusedImportsFromLockFile() error {
	// traverse and remove imports from package-lock.json
	logger := log.FromContext(b.ctx)

	logger.Debug().Msg("not implemented")

	return nil
}

func (b *Builder) removeUnusedImportsFromDependencyFile() error {
	// traverse and remove imports from package.json
	logger := log.FromContext(b.ctx)

	logger.Warn().Msg("not implemented")

	return nil
}

func (b *Builder) discoverUsedImports() error {
	// traverse each import found in the entrypoint file, scanning for
	// absolute dependencies managed by node_modules
	logger := log.FromContext(b.ctx)

	if !b.target.RemoveUnusedImports {
		logger.Info().Msg("target is configured to ignore unused imports")
		return nil
	}

	logger.Warn().Msg("not implemented")

	return nil
}

func (b *Builder) removeUnusedImports() error {
	logger := log.FromContext(b.ctx)

	if !b.target.DryRun {
		logger.Info().Msg("target is configured for dry run; won't remove unused imports")
		return nil
	}

	if !b.target.RemoveUnusedImports {
		logger.Info().Msg("target is configured to ignore unused imports")
		return nil
	}

	if b.target.IgnoreLockFile {
		return b.removeUnusedImportsFromDependencyFile()
	}

	return b.removeUnusedImportsFromLockFile()
}

// copyBuildFiles copies all files in the Target's project root to this Builder's build directory.
func (b *Builder) copyBuildFiles() error {
	logger := log.FromContext(b.ctx)

	if !b.target.DryRun {
		logger.Info().Msg("target is configured for dry run; won't copy build files")
		return nil
	}

	logger.Warn().Msg("not implemented")

	return nil
}

// createBuildArtifact creates a build artifact using files in the temporary build directory.
func (b *Builder) createBuildArtifact() error {
	logger := log.FromContext(b.ctx)

	if !b.target.DryRun {
		logger.Info().Msg("target is configured for dry run; won't create a build artifact")
		return nil
	}

	logger.Warn().Msg("not implemented")

	return nil
}

// cleanup removes the temporary build directory and any unused side effects generated by this
// build process.
func (b *Builder) cleanup() {
	logger := log.FromContext(b.ctx)

	if !b.target.DryRun {
		logger.Info().Msg("target is configured for dry run; nothing to cleanup")
	}
}

// buildDir creates a temporary build directory and sets this Builder's buildDir
// property to that directory.
func (b *Builder) createBuildDir() error {
	logger := log.FromContext(b.ctx)
	// if dry run, carry out dry run build using actual project root since no side effects
	// will be performed
	if !b.target.DryRun {
		logger.Info().Msg("target is configured for dry run; won't create a new build directory")
		b.buildDir = b.target.ProjectRoot

		return nil
	}

	dir, err := os.MkdirTemp("", "butler_build")
	if err != nil {
		return err
	}
	b.buildDir = dir

	return nil
}

func (b *Builder) Build() error {
	defer b.cleanup()

	logger := log.FromContext(b.ctx)
	logger.Info().Bool("dry_run", b.target.DryRun).Msg("building")

	var err error
	if err = b.createBuildDir(); err != nil {
		return err
	}
	if err = b.copyBuildFiles(); err != nil {
		return err
	}
	if err = b.discoverUsedImports(); err != nil {
		return err
	}
	if err = b.removeUnusedImports(); err != nil {
		return err
	}
	if err = b.createBuildArtifact(); err != nil {
		return err
	}

	logger.Warn().Msg("not implemented")

	return err
}
