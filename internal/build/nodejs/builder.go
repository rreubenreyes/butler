package nodejs

import (
	"context"
	"os"

	"github.com/rreubenreyes/butler/internal/log"
)

type Builder struct {
	entry              string
	dryRun             bool
	opts               *Options
	ctx                context.Context
	buildDir           string
	usedImports        []string
	dependencyFilePath string
	lockFilePath       string
}

func (b *Builder) removeUnusedImportsFromLockFile() error {
	// traverse and remove imports from package-lock.json
	logger := log.FromContext(b.ctx)

	logger.Debug().Msg("not implemented")

	return nil
}

func (b *Builder) removeUnusedImportsFromDependencyFile() error {
	// traverse and remove imports from package.json
	logger := log.FromContext(b.ctx)

	logger.Warn().Msg("not implemented")

	return nil
}

func (b *Builder) discoverUsedImports() error {
	// traverse each import found in the entrypoint file, scanning for
	// absolute dependencies managed by node_modules
	logger := log.FromContext(b.ctx)

	if !b.opts.RemoveUnusedImports {
		logger.Info().Msg("opts is configured to ignore unused imports")
		return nil
	}

	logger.Warn().Msg("not implemented")

	return nil
}

func (b *Builder) removeUnusedImports() error {
	logger := log.FromContext(b.ctx)

	if !b.dryRun {
		logger.Info().Msg("opts is configured for dry run; won't remove unused imports")
		return nil
	}

	if !b.opts.RemoveUnusedImports {
		logger.Info().Msg("opts is configured to ignore unused imports")
		return nil
	}

	if b.opts.IgnoreLockFile {
		return b.removeUnusedImportsFromDependencyFile()
	}

	return b.removeUnusedImportsFromLockFile()
}

// copyBuildFiles copies all files in the Target's project root to this Builder's build directory.
func (b *Builder) copyBuildFiles() error {
	logger := log.FromContext(b.ctx)

	if !b.dryRun {
		logger.Info().Msg("opts is configured for dry run; won't copy build files")
		return nil
	}

	logger.Warn().Msg("not implemented")

	return nil
}

// createBuildArtifact creates a build artifact using files in the temporary build directory.
func (b *Builder) createBuildArtifact() error {
	logger := log.FromContext(b.ctx)

	if !b.dryRun {
		logger.Info().Msg("opts is configured for dry run; won't create a build artifact")
		return nil
	}

	logger.Warn().Msg("not implemented")

	return nil
}

// cleanup removes the temporary build directory and any unused side effects generated by this
// build process.
func (b *Builder) cleanup() {
	logger := log.FromContext(b.ctx)

	if !b.dryRun {
		logger.Info().Msg("target is configured for dry run; nothing to cleanup")
	}
}

// buildDir creates a temporary build directory and sets this Builder's buildDir
// property to that directory.
func (b *Builder) createBuildDir() error {
	logger := log.FromContext(b.ctx)
	// if dry run, carry out dry run build using actual project root since no side effects
	// will be performed
	if !b.dryRun {
		logger.Info().Msg("target is configured for dry run; won't create a new build directory")
		b.buildDir = b.opts.ProjectRoot

		return nil
	}

	dir, err := os.MkdirTemp("", "butler_build")
	if err != nil {
		return err
	}
	b.buildDir = dir

	return nil
}

func (b *Builder) Build() error {
	defer b.cleanup()

	logger := log.FromContext(b.ctx)
	logger.Info().Bool("dry_run", b.dryRun).Msg("building")

	pipeline := []func() error{
		b.createBuildDir,
		b.copyBuildFiles,
		b.discoverUsedImports,
		b.removeUnusedImports,
		b.createBuildArtifact,
	}

	for _, step := range pipeline {
		err := step()
		if err != nil {
			return err
		}
	}

	logger.Warn().Msg("not implemented")
	return nil
}
